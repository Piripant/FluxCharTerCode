// Generated by CoffeeScript 1.10.0
(function() {
  var ignore, inter_funcs, math_funcs, normal_seps, scopes_exps, separators, starts, trans, vars_dict,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  math_funcs = {
    "pi": "Math.PI",
    "sin": "Math.sin",
    "cos": "Math.cos",
    "tan": "Math.tan",
    "abs": "Math.abs",
    "mod": "%",
    "^": "**"
  };

  inter_funcs = {
    "input": "prompt",
    "output": "intprtAlert"
  };

  trans = Object.assign(math_funcs, inter_funcs);

  ignore = ["=", "-", "+", "*", "/", "\'", "\"", "(", ")", "<", ">"];

  starts = ["\"", "\'"];

  scopes_exps = "(\'[\\s\\S]*?\')|(\"[\\s\\S]*?\")";

  normal_seps = "\\s|(\\*)|(\\-)|(\\+)|(\\/)|(\")|(\')|(\\=)|(\\^)|(\\()|(\\))|(\\<)|(\\>)";

  separators = new RegExp(scopes_exps + "|" + normal_seps);

  vars_dict = {};

  this.compile = function(text, type) {
    var exp, exps, i, j, ref, ref1, result, trans_keys;
    exps = text.split(separators);
    i = 0;
    while (i < exps.length) {
      if (exps[i] === void 0 || exps[i] === "") {
        exps.splice(i, 1);
      } else {
        i += 1;
      }
    }
    trans_keys = Object.keys(trans);
    for (i = j = 0, ref = exps.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      exp = exps[i];
      if (indexOf.call(trans_keys, exp) >= 0) {
        exps[i] = trans[exp];
      } else if (indexOf.call(ignore, exp) < 0 && (ref1 = exp[0], indexOf.call(starts, ref1) < 0) && isNaN(exp)) {
        exps[i] = "vars_dict[\"" + exp + "\"]";
      }
    }
    result = exps.join("");
    return result;
  };

  this.eraseVars = function() {
    return vars_dict = {};
  };

  this.stop = false;

  this.InterpreteBox = function(startBox) {
    var error, ex;
    if (!this.stop) {
      try {
        if (startBox.type === cmdName || startBox.type === interName) {
          console.log("Here!");
          eval(startBox.compText);
          if (startBox.yesBox) {
            return InterpreteBox(startBox.yesBox);
          }
        } else {
          if (eval(startBox.compText)) {
            if (startBox.yesBox) {
              return InterpreteBox(startBox.yesBox);
            }
          } else {
            if (startBox.noBox) {
              return InterpreteBox(startBox.noBox);
            }
          }
        }
      } catch (error) {
        ex = error;
        alert("An execution error was raised, see console for more details");
        return console.log(ex);
      }
    } else {
      return this.stop = false;
    }
  };

}).call(this);
